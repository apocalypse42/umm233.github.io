<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宇宙人的小怪屋</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://umm233.github.io/"/>
  <updated>2018-12-02T15:11:49.792Z</updated>
  <id>https://umm233.github.io/</id>
  
  <author>
    <name>Seeno</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>拼图优化</title>
    <link href="https://umm233.github.io/p/6f136742/"/>
    <id>https://umm233.github.io/p/6f136742/</id>
    <published>2018-11-29T07:21:36.000Z</published>
    <updated>2018-12-02T15:11:49.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情"><a href="#前情" class="headerlink" title="前情"></a>前情</h2><p>之前粗糙写了一个实现根据模板形状拼图的程序，最明显的缺点就是，拼出来形状，但是丢失了原有图片的颜色。<br>然后“基于搜索引擎“优化了一下。主要参考</p><blockquote><p>主要是发现了 <code>Image</code>  库里的 <code>blend</code> 函数 和 <code>composite</code>函数。</p></blockquote><a id="more"></a><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ul><li>方法一（推荐）</li></ul><blockquote><p><code>blend</code>函数简介<br>定义：Image.blend(image1,image2, alpha) ⇒ image<br>含义：使用给定的两张图像及透明度变量alpha，插值出一张新的图像。这两张图像必须有一样的尺寸和模式。<br>合成公式为：out = image1 <em>(1.0 - alpha) + image2 </em> alpha</p></blockquote><pre><code>im1 = Image.open(&quot;Image1.png&quot;)im2 = Image.open(&quot;Image2.png&quot;)im = Image.blend(im1,im2,0.618) im.save(&quot;pin-pic.png&quot;)</code></pre><blockquote><p>这里0.618是黄金比例值，<del>偷懒随便选的</del></p></blockquote><p>关于参数设置，简单来说，如果变量alpha为0.0，将返回第一张图像的拷贝。如果变量alpha为1.0，将返回第二张图像的拷贝。对变量alpha的值没有限制。<br>这里的话:</p><blockquote><p>如果设置为 0，那么显示<code>Image1.png</code><br>如果设置为 1，那么显示<code>Image2.png</code></p></blockquote><p>效果图：</p><p><img src="/p/6f136742/tmdu1-12-0.618.png" alt="tmdu1-12-0.618"></p><ul><li>方法二（不太好看🙃）</li></ul><blockquote><p><code>Composite</code>函数简介<br>定义：Image.composite(image1,image2, mask) ⇒ image<br>含义：使用给定的两张图像及mask图像作为透明度，插值出一张新的图像。变量mask图像的模式可以为“1”，“L”或者“RGBA”。所有图像必须有相同的尺寸。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">im1 = Image.open(&quot;Image1.png&quot;)</span><br><span class="line">im2 = Image.open(&quot;Image2.png&quot;)</span><br><span class="line"># 因为下面要对图像的RGB三通道进行分割，所以这里将格式转换为RGB</span><br><span class="line">im1 = im1.convert(&quot;RGB&quot;)</span><br><span class="line">im2 = im2.convert(&quot;RGB&quot;)</span><br><span class="line">r,g,b = im1.split() # 通道分离</span><br><span class="line">print(g.mode)</span><br><span class="line">im = Image.composite(im1,im2,g)</span><br><span class="line">im.save(&quot;pin-pic.jpg&quot;)</span><br><span class="line">b.save(&quot;image-b.jpg&quot;)</span><br></pre></td></tr></table></figure><p>效果图:</p><p><img src="/p/6f136742/tmdu2-12-b1.png" alt="tmdu2-12-b1"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Image</code>库，博大精深…我只取一粟😂<br>写起来只有这一点点，但是实际测试了很多，之前将图片格式转为RGBA，尝试修改alpha通道，没有效果，不知道那个地方不对，然后测试了许多图片透明化的方法，最后看到一篇文章介绍了<code>Image</code>库的一些具体函数，找到以上两个函数解决。对自己来说，由于对<code>Image</code>库还不够熟悉，兜兜转转，又回到<code>Image</code> …<del>悲伤的故事</del></p><p>不存在的Flag：有空把各部分的函数结构还有固定参数修改一下，做的精细一点，多注意下细节优化和交互体验等等。<del>挖坑</del></p><p>PS.今年时间进度提醒</p><p>今年还剩下 29 天<br>▓▓▓▓▓▓▓▓▓▓▓▓▓░░  92%</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/chimeiwangliang/p/7130434.html&quot;" rel="external nofollow noopener noreferrer" target="_blank">第一篇 Python图片处理模块PIL（pillow）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前情&quot;&gt;&lt;a href=&quot;#前情&quot; class=&quot;headerlink&quot; title=&quot;前情&quot;&gt;&lt;/a&gt;前情&lt;/h2&gt;&lt;p&gt;之前粗糙写了一个实现根据模板形状拼图的程序，最明显的缺点就是，拼出来形状，但是丢失了原有图片的颜色。&lt;br&gt;然后“基于搜索引擎“优化了一下。主要参考&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主要是发现了 &lt;code&gt;Image&lt;/code&gt;  库里的 &lt;code&gt;blend&lt;/code&gt; 函数 和 &lt;code&gt;composite&lt;/code&gt;函数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://umm233.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://umm233.github.io/tags/Python/"/>
    
      <category term="图像处理" scheme="https://umm233.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>PIL实现图片拼接</title>
    <link href="https://umm233.github.io/p/1e3f5113/"/>
    <id>https://umm233.github.io/p/1e3f5113/</id>
    <published>2018-11-22T04:58:41.000Z</published>
    <updated>2018-11-24T05:44:42.040Z</updated>
    
    <content type="html"><![CDATA[<p>捡起之前想做的图片拼接：刚学Python的时候一个图，将各种图拼起来做成特定的形状，觉得很酷<del>然后刚开始各种百度图片拼接程序</del>，未果。这两天闲下来就想动动手，想给做出来。<br>然后经过一番挣扎，有点丑的做出来了😂<br>效果图如下：(最好模板图片背景是白色的)</p><p><img src="/p/1e3f5113/result-2018-11-22-13-47-22.png" alt="result-2018-11-22-13-47-22"></p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>将像素点“替换”成图片，设置一个灰度值作为阈值来选择要替换成图片的像素点，然后再新建图里将图片粘贴上去。</p></blockquote><p>PS.思路就是这么简单粗暴</p><h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h2><h3 id="1-读取图片基本信息及改变像素模式"><a href="#1-读取图片基本信息及改变像素模式" class="headerlink" title="1. 读取图片基本信息及改变像素模式"></a><strong>1. 读取图片基本信息及改变像素模式</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modelImg = Image.open(model_path) # 模板图片</span><br><span class="line">im1 = modelImg.resize((500,500)) # 重设modelImg的尺寸</span><br><span class="line">print(&quot;修改后模板图像尺寸为: &quot;,im1.size) </span><br><span class="line">width,height = im1.size # 模板图片尺寸</span><br></pre></td></tr></table></figure><blockquote><p>刚开始对图像没有什么概念，后来发现一共有九种不同的像素模式，分别是 1，L，P，RGB，RGBA，CMYK，YCbCr，I，F。具体概念可以参考：<a href="https://blog.csdn.net/icamera0/article/details/50843172" target="_blank" rel="noopener">Python图像处理库PIL中图像格式转换（一）</a></p></blockquote><p>这里简单起见就选择 <code>L</code> 模式</p><blockquote><p>模式“L”为灰色图像，它的每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度。</p></blockquote><p><strong>将图片像素格式统一转换成灰度值，方面后面阈值操作。</strong></p><p>这是一个坑，不同的图片如果直接利用<code>Image</code>库里的<code>getpixel</code>函数就会出现有的时候返回的是RGB,RGBA,P或者L的，每次的像素格式都不一样，传参都麻烦起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">im = im1.convert(&quot;L&quot;)</span><br></pre></td></tr></table></figure><h3 id="2-读取模板图片像素值存入数组"><a href="#2-读取模板图片像素值存入数组" class="headerlink" title="2. 读取模板图片像素值存入数组"></a><strong>2. 读取模板图片像素值存入数组</strong></h3><blockquote><p>这一步在改变模式后就很容易实现了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def openModel(model_path):</span><br><span class="line">    modelImg = Image.open(model_path)</span><br><span class="line">    im1 = modelImg.resize((500,500)) # 重设模板图片的尺寸，为了避免最后成图顺序出错</span><br><span class="line">    print(&quot;修改图像尺寸为: &quot;,im1.size)</span><br><span class="line">    width,height = im1.size # 修改后的图片尺寸</span><br><span class="line"></span><br><span class="line">    # 修改图像模式为:</span><br><span class="line">    im = im1.convert(&quot;L&quot;)</span><br><span class="line">    print(&quot;修改图像模式为: &quot;,im.mode)</span><br><span class="line">    # 读取像素值</span><br><span class="line">    array = [] # 存放像素值的列表</span><br><span class="line">    </span><br><span class="line">    # 优化一下采集方式，不是每个点都要采集</span><br><span class="line">    # 否则一张100x100的图片，拼接50x50的图片之后的大小会是5000x5000</span><br><span class="line">    for x in range(0, width, 10): </span><br><span class="line">        for y in range(0, height, 10):</span><br><span class="line">            pixel = im.getpixel((x,y)) # 读取像素点灰度值</span><br><span class="line">            array.append(pixel)</span><br><span class="line">    # print(array)</span><br><span class="line">    # print(len(array))</span><br><span class="line">    return array</span><br></pre></td></tr></table></figure><h3 id="3-图片拼接"><a href="#3-图片拼接" class="headerlink" title="3. 图片拼接"></a><strong>3. 图片拼接</strong></h3><p>之前的步骤弄好之后，开始拼接，<code>if</code>语句根据设置的阈值简单判断一下，哪些点是要用图片替代的，然后转换成新图相应的坐标，将图片拼接上去就完成了。时间关系，许多地方就没有考虑太仔细，没去做优化。<del>要考试复习，对我现在就是在浪🙃</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    model_path = getImgPath(<span class="number">0</span>)[<span class="number">1</span>]</span><br><span class="line">    print(model_path)</span><br><span class="line">    <span class="comment"># 新建画布</span></span><br><span class="line">    imnew = Image.new(<span class="string">"RGB"</span>, (<span class="number">2500</span>,<span class="number">2500</span>),<span class="string">"#FFFFFF"</span>)</span><br><span class="line">    piclen = <span class="number">1654</span> <span class="comment"># 文件夹下拼接图片数量</span></span><br><span class="line">    array = openModel(model_path) <span class="comment"># 模板像素点数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">        <span class="keyword">if</span>(i &lt; piclen):</span><br><span class="line">            picI = i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            picI = i<span class="number">-1000</span> <span class="comment"># 这里是图不够了😂</span></span><br><span class="line">        pasteImg = getImgPath(picI)[<span class="number">0</span>] <span class="comment"># 第picI张图片</span></span><br><span class="line">        imgpaste = Image.open(pasteImg).resize((<span class="number">50</span>,<span class="number">50</span>)) <span class="comment"># 统一用于拼接图片的尺寸</span></span><br><span class="line">        <span class="comment"># imgpaste = Image.open(modelImg).resize((50,50))</span></span><br><span class="line">        <span class="comment"># 行 Row 列 Column</span></span><br><span class="line">        row, column = i/<span class="number">50</span>,i%<span class="number">50</span> <span class="comment"># 行列值，相当于图片在新图中的坐标</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">10</span> &lt; array[i] &lt; <span class="number">245</span>):</span><br><span class="line">            imnew.paste(imgpaste,(int(row*<span class="number">50</span>), int(column*<span class="number">50</span>)))</span><br><span class="line">            print(<span class="string">"正在拼接第 %d 张图，还剩下 %d 张"</span> %(i,len(array)-i))</span><br><span class="line">            <span class="comment"># print((int(row*50), int(column*50)))</span></span><br><span class="line">    imnew.show()</span><br></pre></td></tr></table></figure><h3 id="待优化"><a href="#待优化" class="headerlink" title="待优化"></a>待优化</h3><ol><li>颜色分布与原图匹配</li><li>运行速度</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这次呢做出了想要的目标效果，但是很多地方没有异常处理，用老师的话说就是程序不够“壮”(健壮性)</p><p>在思路方面以前最开始没做出出来就是以为那时候想法不对：只想着在原图上将图片直接替换像素点，然后搜索资料的发现也被带偏。后来换个方法，不在原图操作，那我自己重新画一张图出来不就好了 (√)。</p><p>除了思路之外，中间过程的一些地方，文件路径什么的，还是瞎(shi)操(jian)作(jin)<br>处理图像先对图像的基本情况稍作了解，后面会少走许多弯路。</p><p>程序公开在Github上：<a href="https://github.com/umm233/SeeNo/blob/master/pinaddfile.py" target="_blank" rel="noopener">图片拼接</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/icamera0/article/details/50843172" target="_blank" rel="noopener">Python图像处理库PIL中图像格式转换（一）</a></li><li><a href="https://blog.csdn.net/icamera0/article/details/50706615" target="_blank" rel="noopener">Python图像处理库PIL的Image模块介绍（四）</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;捡起之前想做的图片拼接：刚学Python的时候一个图，将各种图拼起来做成特定的形状，觉得很酷&lt;del&gt;然后刚开始各种百度图片拼接程序&lt;/del&gt;，未果。这两天闲下来就想动动手，想给做出来。&lt;br&gt;然后经过一番挣扎，有点丑的做出来了😂&lt;br&gt;效果图如下：(最好模板图片背景是白色的)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/p/1e3f5113/result-2018-11-22-13-47-22.png&quot; alt=&quot;result-2018-11-22-13-47-22&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://umm233.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://umm233.github.io/tags/Python/"/>
    
      <category term="图像处理" scheme="https://umm233.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2DPSK波形</title>
    <link href="https://umm233.github.io/p/d5a52b94/"/>
    <id>https://umm233.github.io/p/d5a52b94/</id>
    <published>2018-11-18T12:26:44.000Z</published>
    <updated>2018-11-24T04:07:38.271Z</updated>
    
    <content type="html"><![CDATA[<p>最近写作业要画各种各样的波形（eg.2DPSK），就很烦，有的地方总画错(<del>真实原因是画的丑</del>)<br>然后就写了个程序画得整整齐齐来看，顺便加深理解。</p><a id="more"></a><blockquote><p>2DPSK简称为二进制差分相移键控，它不是利用载波相位的绝对数值传送数字信息，而是用前后码元的相对载波相位值传送数字信息。所谓相对载波相位是指本码与前一码元初相之差。——引自百度百科的定义</p></blockquote><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>1.根据其定义，相位变化是由输入的码元(0/1)决定的（默认初始参考相位为0）<br>2.用一个数组delta将每次变化的相位记录下来，用deltaAdd累加每次的变化量形成最终的相位<br>3.细节处理：</p><blockquote><p>要考虑到每个周期产生的波形数量，其可通过下面这个公式计算出。</p></blockquote><p>$$<br>T_B = f_c/R_b<br>$$</p><h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><blockquote><p>主要用到<code>numpy</code>和 <code>matplotlib</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 预设用于检测的绝对码，Tb，fai0，fai1，后面可以作为参数输入</span><br><span class="line">mustCode = [0,1,1,0,1,0]</span><br><span class="line">Tb = 1.5*2*np.pi # 一个波形周期</span><br><span class="line">fai0 = 1.5*np.pi # 码字为0时波形的移动相位：270°</span><br><span class="line">fai1 = 0.5*np.pi # 码字为1时波形的移动相位：90°</span><br><span class="line"></span><br><span class="line">for i in range(len(mustCode)):</span><br><span class="line">    if mustCode[i] == 1:</span><br><span class="line">        delta.append(fai1)</span><br><span class="line">    else:</span><br><span class="line">        delta.append(fai0)</span><br><span class="line">    deltaAdd = deltaAdd + delta[i] # 累计每次的相位变化</span><br><span class="line">    x1 = np.linspace((i+1)*Tb, i*Tb+2*Tb, 100)</span><br><span class="line">    y1 = np.sin(x1 + deltaAdd)</span><br><span class="line">    plt.plot(x1,y1)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><pre><code>### 更新一下下，加一个判断，因为2DPSK有不同的情况存在。    if forwordOrlast == &apos;1&apos;:        deltaAdd = deltaAdd + delta[i] # 2DPSK之与前一波形末相位的相位差    elif forwordOrlast == &apos;0&apos;:        deltaAdd = deltaAdd + delta[i] - Tb # 2DPSK之与前一波形初相位的相位差    else:        print(&quot;input data is wrong&quot;)</code></pre><h2 id="结果截图"><a href="#结果截图" class="headerlink" title="结果截图"></a>结果截图</h2><p><img src="/p/d5a52b94/2DPSK011010.png" alt="2DPSK011010"></p><p>程序公开在Github上：<a href="https://github.com/umm233/SeeNo/blob/master/2DPSKNEW.py" target="_blank" rel="noopener">2DPSK波形程序实现</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>按思路写起来就是这样子，后面就是将那些预设的量用<code>input()</code>输入就好了。<br>还有就是图像上的优化，怎么弄起来好看一些…比如将横坐标用pi的倍数来表示，加上网格等等。</p><p>自己动手，丰衣足食😜</p><p>PS.今年还剩下 43 天<br>▓▓▓▓▓▓▓▓▓▓▓▓▓░░  88%</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近写作业要画各种各样的波形（eg.2DPSK），就很烦，有的地方总画错(&lt;del&gt;真实原因是画的丑&lt;/del&gt;)&lt;br&gt;然后就写了个程序画得整整齐齐来看，顺便加深理解。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://umm233.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://umm233.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>修改next博客logo</title>
    <link href="https://umm233.github.io/p/8a74e107/"/>
    <id>https://umm233.github.io/p/8a74e107/</id>
    <published>2018-11-09T12:35:09.000Z</published>
    <updated>2018-11-18T12:27:24.395Z</updated>
    
    <content type="html"><![CDATA[<p>每次看完番，都有一些不(da)安(dan)分的想法，于是乎就折腾博客logo，但总是忘记怎么改/无奈…</p><p>于是乎记录一下。</p><a id="more"></a><ul><li><p>生成图标文件</p><blockquote><p>在 <a href="https://www.easyicon.net/covert/" rel="external nofollow noopener noreferrer" target="_blank">easyicon</a>上传喜欢的图片，然后可以转换成各种尺寸大小，eg.16x16,32x32,128x128等等，ps.图片生成格式支持选择<code>Microsoft.icon</code>和<code>MacOs.icon</code>，一般博客logo大小转换成32x32就ok了。</p></blockquote></li><li><p>修改logo</p><blockquote><p>这个地方我一直搞混了😂，其实应该很清楚才是。在<code>themes\next\source\images</code>这个文件夹下有一些<code>.ico</code>后缀的文件可以不动它们，直接讲自己的logo文件放入，这样就ok了。</p></blockquote></li><li><p>修改主题配置文件</p><blockquote><p>在<code>themes\next\_config.yml</code>中找到<code>favicon</code>这一项，修改成对应的文件名就好了。</p></blockquote></li></ul><p>eg.</p><blockquote><p>small: /images/favicon.ico<br>medium: /images/favicon-32x32.ico</p></blockquote><p>然后，常规套路<code>hexo clean</code>-&gt;<code>hexo g</code>-&gt;<code>hexo s</code>-&gt;<code>hexo d</code></p><p>大功告成…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每次看完番，都有一些不(da)安(dan)分的想法，于是乎就折腾博客logo，但总是忘记怎么改/无奈…&lt;/p&gt;
&lt;p&gt;于是乎记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://umm233.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Hexo" scheme="https://umm233.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>今年时间进度</title>
    <link href="https://umm233.github.io/p/5a3f823d/"/>
    <id>https://umm233.github.io/p/5a3f823d/</id>
    <published>2018-11-02T15:03:26.000Z</published>
    <updated>2018-11-02T15:51:14.907Z</updated>
    
    <content type="html"><![CDATA[<p>参考即刻「今年的时间进度变更提醒」<br>做了一个一模(mao)一样的…<br>Interesting!</p><a id="more"></a><p>只要用<code>time</code>库就可以实现</p><h2 id="判断平闰年"><a href="#判断平闰年" class="headerlink" title="判断平闰年"></a>判断平闰年</h2><blockquote><p>根据平闰年的概念定义进行判断</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def judgeYear(year):</span><br><span class="line">    if (year%4 == 0) &amp; (year%100 != 0):</span><br><span class="line">        allday = 366</span><br><span class="line">    elif year%400 == 0:</span><br><span class="line">        allday = 366</span><br><span class="line">    else:</span><br><span class="line">        allday = 365</span><br><span class="line">    return allday</span><br></pre></td></tr></table></figure><h2 id="time库"><a href="#time库" class="headerlink" title="time库"></a>time库</h2><blockquote><p>这是一个很基础的，也很常用的库<br><code>time.localtime()</code>返回的是一个类(class)<br> 返回的是time.struct_time(tm_year=2018, tm_mon=11, tm_mday=2, tm_hour=23, tm_min=24, tm_sec=46, tm_wday=4, tm_yday=306, tm_isdst=0)<br>尝试print你就知道每个变量的含义了，其实看名字也一目了然……<br>那这个程序里，我要的只是，“今天是一年中的第几天”，即<code>tm_yday</code><br>调用的话就是 <code>time.localtime().tm_yday</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localt = time.localtime()</span><br><span class="line"># print(localt)</span><br><span class="line">allday = judgeYear(localt.tm_year)</span><br></pre></td></tr></table></figure><h2 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h2><blockquote><p>进度条想设计成什么样看个人，也可以用turtle画一个，也蛮简单的<br>这里用的是文本进度条<br>简单粗暴，字符相加，就成一家</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sad = yday/allday # 一年进度 sad~</span><br><span class="line">scale = 15 # 进度条长度</span><br><span class="line">i = int(15*sad)</span><br><span class="line">passed = &apos;▓&apos; * i # 今年走过的%</span><br><span class="line">leave = &apos;░&apos; * (scale - i) # 今年剩下的%</span><br><span class="line">print(&quot;\r&#123;0&#125;&#123;1&#125; &#123;2:3.0f&#125;% \n&quot;.format(passed,leave,sad*100),end=&apos;&apos;)</span><br></pre></td></tr></table></figure><p>▓▓▓▓▓▓▓▓▓▓▓▓░░░  84% </p><p>至此一个进度条就出来了 <a href="https://github.com/umm233/SeeNo/blob/master/missDay.py" target="_blank" rel="noopener">完整代码</a></p><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>今年只剩下59天了，还有很多东西想学好🙃🙃🙃，加把劲了~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考即刻「今年的时间进度变更提醒」&lt;br&gt;做了一个一模(mao)一样的…&lt;br&gt;Interesting!&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://umm233.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://umm233.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>caj转pdf并添加书签</title>
    <link href="https://umm233.github.io/p/49abadb9/"/>
    <id>https://umm233.github.io/p/49abadb9/</id>
    <published>2018-10-28T09:55:47.000Z</published>
    <updated>2018-11-03T01:23:40.085Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为一些莫须有的原因阅览caj文件，需要转成pdf文件。<br>简单呀：CAJviewr里利用打印就可以生成PDF</p><blockquote><p>缺点：转换得到的是图片构成的pdf，这下不舒服了</p></blockquote><a id="more"></a><p>换方法：在GitHub上看到一个项目 <strong><a href="https://github.com/JeziL/caj2pdf" target="_blank" rel="noopener">caj2pdf</a></strong>，但···😥作者如是说:</p><blockquote><p>Convert CAJ (China Academic Journals) files to PDF. 转换中国知网 CAJ 格式文献为 PDF。佛系转换，成功与否，皆是玄学。</p></blockquote><p>再换：那就从根本上入手，直接从知网上<code>down pdf</code></p><blockquote><p>想起之前藏的一个脚本：<a href="https://greasyfork.org/zh-CN/scripts/18842-cnki-中国知网-pdf-全文下载-特制版" rel="external nofollow noopener noreferrer" target="_blank">CNKI 中国知网 PDF 全文下载（特制版）</a></p></blockquote><p>终于，有点顺了，问题来了，down下来的内容虽然不是图片了，但是没有目录，这么多页，看锤子？嗯，后来被坑了点，走了弯路 /心情复杂。最后用的这个解决🙁</p><blockquote><p><code>Freepictopdf</code>和<code>PdgCntEditor</code>然后参见<a href="https://zhuanlan.zhihu.com/p/47271995" rel="external nofollow noopener noreferrer" target="_blank">如何用FreePic2Pdf和PdgCntEditor制作目录</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为一些莫须有的原因阅览caj文件，需要转成pdf文件。&lt;br&gt;简单呀：CAJviewr里利用打印就可以生成PDF&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;缺点：转换得到的是图片构成的pdf，这下不舒服了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://umm233.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="小技巧" scheme="https://umm233.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python的sort函数</title>
    <link href="https://umm233.github.io/p/8394e334/"/>
    <id>https://umm233.github.io/p/8394e334/</id>
    <published>2018-10-02T14:45:19.000Z</published>
    <updated>2018-10-29T05:56:59.670Z</updated>
    
    <content type="html"><![CDATA[<p><code>sort</code>函数小记</p><blockquote><p>list.sort(cmp=None, key=None, reverse=False)<br>l<em>   cmp – 可选参数, 如果指定了该参数会使用该参数的方法进行排序。<br>l</em>   key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。<br>l*   reverse – 排序规则，reverse = True 降序， reverse = False 升序（默认）。</p></blockquote><a id="more"></a><p>关于sort函数的坑是在做<code>Leetcode</code>的时候发现的，为了偷懒，坑了自己…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [1,4,2,6,3,8]</span><br><span class="line">b = a.sort() # 错误的用法</span><br><span class="line">print(a) # 结果是[1,2,3,4,6,8]</span><br><span class="line">print(b) # None</span><br><span class="line">print(type(b)) # 结果是 &lt;class &apos;NoneType&apos;&gt;</span><br></pre></td></tr></table></figure><p>刚开始觉得没毛病，但是<code>b</code>没有取值，然后去查了一下，sort函数返回的就是<code>None</code>，<code>a.sort()</code>将<code>a</code>排序好后，不返回值，直接对<code>a</code>本身进行操作。</p><h5 id="参数说明参考-菜鸟教程"><a href="#参数说明参考-菜鸟教程" class="headerlink" title="参数说明参考 菜鸟教程"></a>参数说明参考 <a href="http://www.runoob.com/python/att-list-sort.html" rel="external nofollow noopener noreferrer" target="_blank">菜鸟教程</a></h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;sort&lt;/code&gt;函数小记&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;list.sort(cmp=None, key=None, reverse=False)&lt;br&gt;l&lt;em&gt;   cmp – 可选参数, 如果指定了该参数会使用该参数的方法进行排序。&lt;br&gt;l&lt;/em&gt;   key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。&lt;br&gt;l*   reverse – 排序规则，reverse = True 降序， reverse = False 升序（默认）。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://umm233.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://umm233.github.io/tags/Python/"/>
    
      <category term="踩坑" scheme="https://umm233.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>Python的深浅拷贝</title>
    <link href="https://umm233.github.io/p/562ac769/"/>
    <id>https://umm233.github.io/p/562ac769/</id>
    <published>2018-10-02T14:00:19.000Z</published>
    <updated>2018-10-29T05:56:59.670Z</updated>
    
    <content type="html"><![CDATA[<p>关于Python中的列表复制操作<br><del>刚开始没注意坑一踩一个准</del></p><a id="more"></a><ul><li>浅拷贝只是将另一个变量指向要复制的变量地址，并没有重新分配地址，所以就会出现“你变我也变”的情况：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2]</span><br><span class="line">b = a</span><br><span class="line">print(id(a))</span><br><span class="line">print(id(b))</span><br><span class="line">a.append(5) </span><br><span class="line">print(b) # 结果是 [1,2,5]</span><br><span class="line"></span><br><span class="line"># 最后会发现 a 和 b 的地址是一样的</span><br><span class="line"># 在 a 的末尾加入5，b 也跟着变了，这就是坑(mmp -_-|||</span><br></pre></td></tr></table></figure><h2 id="–更新-这还是浅拷贝"><a href="#–更新-这还是浅拷贝" class="headerlink" title="–更新 这还是浅拷贝"></a>–更新 <strong>这还是浅拷贝</strong></h2><ul><li>对于<del>深拷贝最简单的方法就是利用<code>copy()</code>函数或者<code>b = a[:]</code>实现：</del></li><li>以下均为浅拷贝的情况： </li></ul><ul><li>使用切片[:]操作</li><li>使用工厂函数（如list/dir/set）</li><li>使用copy模块中的copy()函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2]</span><br><span class="line">b = a.copy()</span><br><span class="line">print(id(a))</span><br><span class="line">print(id(b)) # 结果是 1739769111752</span><br><span class="line">a.append(5)  # 结果是 1739769111496</span><br><span class="line">print(a) # 结果是 [1,2,5]</span><br><span class="line">print(b) # 结果是 [1,2]</span><br><span class="line"></span><br><span class="line"># 这里 a,b 的地址不一样了，在a中添加元素没有对b起作用._.</span><br></pre></td></tr></table></figure><p>！但是，如果列表中嵌套了列表，拷贝后的列表中嵌套的列表元素指针，指向原列表中嵌套列表的整体地址，而不是指向嵌套列表中元素的内存地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s = [[1,2],3,4]</span><br><span class="line">s1 = s.copy()</span><br><span class="line">id(s)</span><br><span class="line">id(s1)</span><br><span class="line">id(s[0][1])</span><br><span class="line">id(s1[0][1])</span><br><span class="line">s.append(&quot;hello&quot;)</span><br><span class="line">print(&quot;s:&quot;,s) </span><br><span class="line">print(&quot;s1:&quot;,s1)   # s: [[1, 2], 3, 4, &apos;hello&apos;]  s1: [[1, 2], 3, 4]</span><br><span class="line">s1[0][1] = &quot;Holy Shit!&quot;</span><br><span class="line">print(&quot;s: &quot;,s)     # s: [[1, &apos;Holy Shit!&apos;], 3, 4, &apos;hello&apos;]</span><br><span class="line">print(&quot;s1:&quot;,s1)  # s1: [[1, &apos;Holy Shit!&apos;], 3,</span><br></pre></td></tr></table></figure><p>在上面的测试中容易发现，在操作列表中的嵌套列表就会出现浅拷贝的问题。</p><p>具体的可以参考: <a href="https://www.cnblogs.com/pyramid1001/p/5844905.html" rel="external nofollow noopener noreferrer" target="_blank">Python——列表深浅拷贝</a></p><p>那么深拷贝的话：利用<code>copy</code>模块的<code>copy.deepcopy(list)</code></p><p>具体可以看看 <a href="https://www.cnblogs.com/wilber2013/p/4645353.html" rel="external nofollow noopener noreferrer" target="_blank">图解Python深拷贝和浅拷贝</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Python中的列表复制操作&lt;br&gt;&lt;del&gt;刚开始没注意坑一踩一个准&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://umm233.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://umm233.github.io/tags/Python/"/>
    
      <category term="踩坑" scheme="https://umm233.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>异步十进制加法加法计数器(VHDL实现)</title>
    <link href="https://umm233.github.io/p/69a664c6/"/>
    <id>https://umm233.github.io/p/69a664c6/</id>
    <published>2018-10-02T09:29:19.000Z</published>
    <updated>2018-10-29T05:56:59.680Z</updated>
    
    <content type="html"><![CDATA[<p>初学VHDL，练手写了一个异步十进制加法计数器，过程有许多细节上的错误，在此记录一下。</p><a id="more"></a><blockquote><p><strong>VHDL</strong>，全称<strong>超高速集成电路硬件描述语言</strong>（英语：<strong><a href="https://zh.wikipedia.org/wiki/VHSIC" title="VHSIC" rel="external nofollow noopener noreferrer" target="_blank">VHSIC</a> very high-speed hardware description language</strong>），在基于<a href="https://zh.wikipedia.org/wiki/%E8%A4%87%E9%9B%9C%E5%8F%AF%E7%A8%8B%E5%BC%8F%E9%82%8F%E8%BC%AF%E8%A3%9D%E7%BD%AE" title="复杂可编程逻辑器件" rel="external nofollow noopener noreferrer" target="_blank">复杂可编程逻辑器件</a>、<a href="https://zh.wikipedia.org/wiki/%E7%8E%B0%E5%9C%BA%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E9%97%A8%E9%98%B5%E5%88%97" title="现场可编程逻辑门阵列" rel="external nofollow noopener noreferrer" target="_blank">现场可编程逻辑门阵列</a>和<a href="https://zh.wikipedia.org/wiki/%E7%89%B9%E6%AE%8A%E6%87%89%E7%94%A8%E7%A9%8D%E9%AB%94%E9%9B%BB%E8%B7%AF" title="专用集成电路" rel="external nofollow noopener noreferrer" target="_blank">专用集成电路</a>的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF" title="数字电路" rel="external nofollow noopener noreferrer" target="_blank">数字系统</a> 设计中有着广泛的应用。（via 维基百科）</p></blockquote><blockquote><ul><li>异步功能实现：信号 <code>clr</code>  高电平实现异步清零<br>十进制：</li><li>利用VHDL中的标准逻辑矢量类型 STD_LOGIC_VECTOR 构建四位的计数变量</li><li>运用 <strong>IF</strong> 语句实现十进制循环 ：“0000” -&gt;“1001” -&gt;“0000”</li><li>利用Quartus进行仿真检测其功能实现</li></ul></blockquote><p>构建实体 <code>tenAdd</code>： <del>瞎起的</del></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entity tenAdd is</span><br><span class="line">    port( clr, clk : in std_logic;</span><br><span class="line">          cnt10: out std_logic_vector (3 downto 0)); -- 设置一个四位矢量计数</span><br><span class="line">end tenAdd;</span><br></pre></td></tr></table></figure><p>条件判断实现计数器循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (clr = &apos;1&apos;) then</span><br><span class="line">   count &lt;= &quot;0000&quot;; -- 0000 要用双引号括起来，单引号只能引单个字符</span><br><span class="line">elsif clk&apos;event and clk = &apos;1&apos; then -- clk上升沿触发计数</span><br><span class="line">  if (count &lt; &quot;1001&quot;) then</span><br><span class="line">    count &lt;= count + 1; -- 计数加1</span><br><span class="line">  else</span><br><span class="line">    count &lt;= &quot;0000&quot;; -- 计数到9之后回到0000</span><br><span class="line">  end if;</span><br><span class="line">end if;</span><br></pre></td></tr></table></figure><p>– PS. 上面的<code>count</code>是在结构体中定义的变量，不需要在实体中提前定义。</p><blockquote><p>1.关于仿真，在Quartus中，新建一个<code>University Program VWF</code>进行波形仿真：<br>2.在<code>Edit</code> -&gt; <code>Insert</code> -&gt; <code>Insert Node or Bus...</code><br>3.在<code>Node Finder...</code> -&gt;<code>List</code> 里面选择要控制和查看的信号</p><ul><li>给<code>clk</code>加一个连续的方波信号观察，输出变量值的变化</li></ul></blockquote><p>一些自己容易忽略的小细节：</p><blockquote><p><code>&lt;=</code>: 用于信号赋值，延迟赋值  – <strong>信号赋初值的时候可以用 := </strong>）<br><code>:=</code>: 用于变量赋值，立即赋值<br>保存文件的时候文件名要和实体名一样，不一致会出现<code>Error: xxx undefined</code></p></blockquote><p>完整代码见github：<a href="https://github.com/umm233/SeeNo/blob/master/tenAdd.vhd" target="_blank" rel="noopener">异步十进制加法计数器</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初学VHDL，练手写了一个异步十进制加法计数器，过程有许多细节上的错误，在此记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://umm233.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="VHDL" scheme="https://umm233.github.io/tags/VHDL/"/>
    
  </entry>
  
  <entry>
    <title>唯一可译码Python实现</title>
    <link href="https://umm233.github.io/p/ee97a480/"/>
    <id>https://umm233.github.io/p/ee97a480/</id>
    <published>2018-09-26T11:29:31.000Z</published>
    <updated>2018-10-29T06:00:44.900Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习信息论，上课讲的概念晦涩，课后自己领悟 <del>老师催眠/无奈</del></p><p>对于唯一可译码，看概念一直绕圈圈，后来看一眼流程图，实践一下明了许多。而后参考网上的算法（Java/C++），自己用Python写了一遍，方便写作业…</p><a id="more"></a><h3 id="算法实现如下"><a href="#算法实现如下" class="headerlink" title="算法实现如下"></a>算法实现如下</h3><blockquote><p>1． 输入原始数据，并用ArrayList()类存储起来；<br>2． 在使用规则之前，先判断是否奇异，如果奇异，将没有进行后续判断的必要，如果非奇异，进入第3步；否则结束程序，输出结果（奇异）；<br>3． 第一次寻找，调用自己设定的seek（array），在初始数据中找到符合条件的尾随后缀，然后进入第4步；<br>4． 通过第一次寻找，可以得到一个arr数组，如果该数组为空，那么就没有必要再进行下去，已经证明找不到更多的尾随后缀了，直接进入第6步；否则进入第5步；<br>5． 通过第一次的寻找，已经得到基本的arr,但是arr是用于判断的，所以首先克隆arr到arrclone中，并且将arr清空，调用seek（array，arrclone）,再将arrclone的字符串和原始数据进行对比，再次得到arr,如果arr为空，进入第6步，否则循环第5步；<br>6． 得到了S，若S为空，则证明不存在尾随后缀，则为即时码，输出结果；若不为空，将原始数据array和S进行对比，若有相同的字符串，则不是唯一可译码，反之，是唯一可译码。</p></blockquote><p>具体代码见github：<a href="https://github.com/umm233/SeeNo/blob/master/%E5%94%AF%E4%B8%80%E5%8F%AF%E8%AF%91%E7%A0%81.py" target="_blank" rel="noopener">唯一可译码Python实现</a></p><h5 id="算法参考-信息论-唯一可译码的判决算法实现（UDC）"><a href="#算法参考-信息论-唯一可译码的判决算法实现（UDC）" class="headerlink" title="算法参考  [信息论]唯一可译码的判决算法实现（UDC）"></a>算法参考 <a href="https://blog.csdn.net/u010536377/article/details/44862493" target="_blank" rel="noopener"> [信息论]唯一可译码的判决算法实现（UDC）</a></h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习信息论，上课讲的概念晦涩，课后自己领悟 &lt;del&gt;老师催眠/无奈&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;对于唯一可译码，看概念一直绕圈圈，后来看一眼流程图，实践一下明了许多。而后参考网上的算法（Java/C++），自己用Python写了一遍，方便写作业…&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://umm233.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://umm233.github.io/tags/Python/"/>
    
      <category term="信息论" scheme="https://umm233.github.io/tags/%E4%BF%A1%E6%81%AF%E8%AE%BA/"/>
    
  </entry>
  
</feed>
